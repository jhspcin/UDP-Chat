import socket
import threading
import random
from datetime import datetime

# Obtenção de data e hora, criação de um socket UDP e solicitação de um input de username
datahora = datetime.now().strftime('%H:%M:%S %d/%m/%Y')
cliente = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
cliente.bind(("localhost", random.randint(8000, 9000)))
nome = input("UserName: ")

def gravafora(mensagem):
    try:
        with open("conversa.txt", "a+") as arquivo:
            arquivo.write(f"{mensagem}\n")
    except IOError as e:
        print(f"Erro: Problemas para gravar fora - {e}")
    except Exception as e:
        print(f"Erro inesperado: {e}")

# Aguarda e printa mensagens recebidas em um socket cliente
def receber():
    while True:
        try:
            mensagens, addr = cliente.recvfrom(1024)
            print(f"\nservidor:~{mensagens.decode()} {datahora}\n")
        except Exception as e:
            print(f"Error em receber: {e}")

# Utilização da biblioteca threading para executar a função receber em segundo plano para
# receber e printar mensagens em um socket cliente enquanto o programa continua executando
t = threading.Thread(target=receber)
t.start()

# Verificação da string inicial para ditar qual funcionalidade do chat será utilizada. 
try:
    if nome.startswith("hi, meu nome eh"):
        nome_real = nome[len("hi, meu nome eh") + 1:]  # Excluindo a parte inicial
        cliente.sendto(f"NewUser:{nome_real}".encode(), ("localhost", 9999))
    else:
        cliente.sendto(f"Chegou!:{nome}".encode(),("localhost",9999))

    while True:
        mensagem = input("Mensagem: ")
            
        if mensagem == "bye":
            exit()
        else:
            cliente.sendto(f"{nome}: {mensagem}".encode(), ("localhost", 9999))
            gravafora(mensagem)
except KeyboardInterrupt:
    print("PROGRAMA INTERROMPIDO")
